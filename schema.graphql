# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"GraphQL representation of a JCR item definition"
interface JCRItemDefinition {
    "Reports whether the item is to be automatically created when its parent node is created."
    autoCreated: Boolean!
    "Gets the node type that contains the declaration of this definition."
    declaringNodeType: JCRNodeType!
    "Reports whether the child item is hidden from UI."
    hidden: Boolean!
    "Reports whether the item is mandatory. A mandatory item is one that, if its parent node exists, must also exist."
    mandatory: Boolean!
    "Gets the name of the child item."
    name: String!
    "Reports whether the child item is protected."
    protected: Boolean!
}

"GraphQL representation of a JCR node"
interface JCRNode {
    "Get the last modified date of this node and its descendants. The recursion in descendants can be controlled by recursionTypesFilter. If no filter is passed, recursion will stop by default on sub pages."
    aggregatedLastModifiedDate(
        #The language to use to get the last modified date, if not specified, returns last modification date in any language
        language: String,
        #Stop recursion on nodes by their types; null to avoid such filtering
        recursionTypesFilter: InputNodeTypesInput
    ): String
    "Aggregated publication info about the JCR node"
    aggregatedPublicationInfo(
        #Publication language
        language: String!,
        #Whether to take references into account when calculating the aggregated publication status
        references: Boolean = false,
        #Whether to take sub-nodes into account when calculating the aggregated publication status
        subNodes: Boolean = false
    ): GqlPublicationInfo!
    ajaxRenderUrl: String
    "Returns a list of types allowed under the provided node"
    allowedChildNodeTypes(
        #Filter by GraphQL fields values
        fieldFilter: InputFieldFiltersInput,
        #Whether all sub-types of allowed child node types should be included
        includeSubTypes: Boolean = true
    ): [JCRNodeType]
    "GraphQL representations of the ancestor nodes of the JCR node, top down direction"
    ancestors(
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput,
        #The path of the topmost ancestor node to include in the result; null or empty string to include all the ancestor nodes
        upToPath: String
    ): [JCRNode]!
    "GraphQL representations of the child nodes, according to parameters passed"
    children(
        #fetching only nodes after this node (exclusive)
        after: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput,
        #Group fields according to specified criteria
        fieldGrouping: InputFieldGroupingInput,
        #Sort by graphQL fields values
        fieldSorter: InputFieldSorterInput,
        #fetching only the first certain number of nodes
        first: Int,
        #Include the current node itself in results
        includesSelf: Boolean = false,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #Filter of child nodes by their names; null to avoid such filtering
        names: [String],
        #fetching only nodes after this node (inclusive)
        offset: Int,
        #Filter of child nodes by their property values; null to avoid such filtering
        propertiesFilter: InputNodePropertiesInput,
        #Filter of child nodes by their types; null to avoid such filtering
        typesFilter: InputNodeTypesInput
    ): JCRNodeConnection!
    "The displayable country name"
    country(locale: String, propertyName: String): String
    "Returns the node definition that applies to this node."
    definition: JCRNodeDefinition
    "GraphQL representation of a descendant node, based on its relative path"
    descendant(
        #Name or relative path of the sub node
        relPath: String!
    ): JCRNode
    "GraphQL representations of the descendant nodes, according to parameters passed"
    descendants(
        #fetching only nodes after this node (exclusive)
        after: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput,
        #Group fields according to specified criteria
        fieldGrouping: InputFieldGroupingInput,
        #Sort by graphQL fields values
        fieldSorter: InputFieldSorterInput,
        #fetching only the first certain number of nodes
        first: Int,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #fetching only nodes after this node (inclusive)
        offset: Int,
        #Filter of descendant nodes by their property values; null to avoid such filtering
        propertiesFilter: InputNodePropertiesInput,
        #Filter out and stop recursion on nodes by their property values; null to avoid such filtering
        recursionPropertiesFilter: InputNodePropertiesInput,
        #Filter out and stop recursion on nodes by their types; null to avoid such filtering
        recursionTypesFilter: InputNodeTypesInput,
        #Filter of descendant nodes by their types; null to avoid such filtering
        typesFilter: InputNodeTypesInput
    ): JCRNodeConnection!
    "The display name of the JCR node this object represents in the requested language"
    displayName(
        #The language to obtain the display name in
        language: String
    ): String
    displayableNode: JCRNode
    "Check if the current user has a specific permission"
    hasPermission(
        #The name of the permission
        permissionName: String!
    ): Boolean
    "Reports if the current node matches the nodetype(s) passed in parameter"
    isNodeType(type: InputNodeTypesInput!): Boolean!
    "Check if the given locales need translation, by comparing last modifications dates with already existing translations"
    languagesToTranslate(
        #List of languages potentially to be translated
        languagesToCheck: [String],
        #List of known translated languages, will be used to compare modifications dates
        languagesTranslated: [String]
    ): [String]
    "Retrieve lock info of the current node"
    lockInfo: LockInfo
    "Returns an array of <code>NodeType</code> objects representing the mixin node types in effect for this node."
    mixinTypes(
        #Filter by GraphQL fields values
        fieldFilter: InputFieldFiltersInput
    ): [JCRNodeType]!
    "The name of the JCR node this object represents"
    name: String!
    "GraphQL representation of this node in certain workspace"
    nodeInWorkspace(
        #The target workspace
        workspace: Workspace!
    ): JCRNode
    "The value of the node's url"
    nodeUrl: String
    "Get information on the operations that can be done on this node"
    operationsSupport: GqlOperationsSupport
    "GraphQL representation of the parent JCR node"
    parent: JCRNode
    "The path of the JCR node this object represents"
    path: String!
    primaryNodeType: JCRNodeType!
    "GraphQL representations of the properties in the requested language"
    properties(
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput,
        #The language to obtain the properties in; must be a valid language code in case any internationalized properties are requested, does not matter for non-internationalized ones
        language: String,
        #The names of the JCR properties; null to obtain all properties
        names: [String]
    ): [JCRProperty]!
    "The GraphQL representation of the property in the requested language; null if the property does not exist"
    property(
        #The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
        language: String,
        #The name of the JCR property
        name: String!
    ): JCRProperty
    "GraphQL representations of the reference properties that target the current JCR Node"
    references(
        #fetching only nodes after this node (exclusive)
        after: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput,
        #fetching only the first certain number of nodes
        first: Int,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #fetching only nodes after this node (inclusive)
        offset: Int
    ): JCRPropertyConnection!
    renderedContent(contextConfiguration: String, language: String, templateType: String, view: String): RenderedNode
    "GraphQL representation of the site the JCR node belongs to, or the system site in case the node does not belong to any site"
    testExtension(arg: String): String
    "The UUID of the JCR node this object represents"
    uuid: String!
    "Get the workspace of the query"
    workspace: Workspace!
}

"Asset type for files"
type Asset {
    metadata: Metadata
    path: String
    size: Long
    type: String
    url: String
    uuid: String
}

"Category type"
type Category {
    description: String
    metadata: Metadata
    path: String
    title: String
    uuid: String
}

"Addon for Cloudinary integration"
type CloudinaryAsset {
    cloudspace: String
    path: String
    url: String
    uuid: String
}

type CountAggregation {
    "Count all values"
    values(
        #The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
        language: String,
        #The name of the JCR property
        name: String!
    ): Int
}

type Destination {
    country: String
    destinationInfo: DestinationInfo
    geoTag: GeoTag
    headerPhoto: ImageAsset
    headline(language: String): String
    highlight: Boolean
    landmarks: [String]
    metadata: Metadata
    name(language: String): String
    outline(language: String): String
    path: String
    photos: [ImageAsset]
    systemName: String
    uuid: String
}

type DestinationInfo {
    area: Float
    elevation: Int
    path: String
    populationCount: Int
    populationDate: String
    uuid: String
}

"Form Factory Elasticsearch Query"
type FFESMutation {
    deleteFormResult(formId: String!, submissionId: String!): Boolean
    deleteFormResults(formId: String!, submissionId: [String]!): Boolean
}

"Form Factory Elasticsearch Query"
type FFESQuery {
    formResults(
        #End date filter
        endDate: String,
        #Form id for from results count
        formId: String!,
        #Current UI language
        language: String,
        #From number of page
        page: Int,
        #page size
        size: Int,
        #Start date filter
        startDate: String
    ): FormResults
    formResultsAverage(
        #time period to calculate average over
        averageBy: AverageBy!,
        #form identifier
        formId: String!
    ): Float
    formResultsLastDays(
        #form identifier
        formId: String!,
        #submissions count within the last number of days
        lastDays: Int!
    ): Float
    hasPermission(
        #ID of the form node, on which the permission check will be performed
        formId: String!,
        #Language in which the permission check should be performed
        language: String!,
        #Name of permission to be checked
        permission: String!
    ): Boolean
    hasValidESConnection(formId: String!): Boolean
    needMigration(formId: String!): Boolean
    submissionTotal(formId: String!): Long
}

"GraphQL object contains data for single field of form"
type FormField {
    fieldId: String
    htmlId: String
    label: String
    values: [String]
}

"GraphQL object contains form result"
type FormResult {
    fields: [FormField]
    id: String
    ipAddress: String
    origin: String
    submissionDate: String
    username: String
}

"GraphQL object contains list of form results"
type FormResults {
    currentPage: Int
    formName: String
    hasNext: Boolean
    hasPrevious: Boolean
    labels: [Label]
    pageSize: Int
    results: [FormResult]
    total: Long
}

type GeoTag {
    latitude: Float
    longitude: Float
    path: String
    uuid: String
}

type GqlBackgroundJob {
    "The amount of time the job ran for (in milliseconds). The returned value will be -1 until the job has actually completed"
    duration: Long
    "The job group name"
    group: String
    "The job (Boolean) property that correspond to the given name. The returned value will be null in case the job doesn't have the property"
    jobBooleanProperty(name: String): Boolean
    "The job (Int) property that correspond to the given name. The returned value will be null in case the job doesn't have the property"
    jobIntegerProperty(name: String): Int
    "The job (Long) property that correspond to the given name. The returned value will be null in case the job doesn't have the property"
    jobLongProperty(name: String): Long
    "The job state is different from the status, it reflect the last action done on the job instance (Started, Vetoed, Finished)"
    jobState: GqlBackgroundJobState
    "The job status"
    jobStatus: GqlBackgroundJobStatus
    "The job (String) property that correspond to the given name. The returned value will be null in case the job doesn't have the property"
    jobStringProperty(name: String): String
    "The job name"
    name: String
    "The site key. The returned value will be null in case the job doesn't have associated site key"
    siteKey: String
    "The user key. The returned value will be null in case the job doesn't have associated user key"
    userKey: String
}

type GqlJcrImageTransformMutation {
    "Crop an image under the current node"
    cropImage(
        #new height
        height: Int!,
        #left
        left: Int!,
        #top
        top: Int!,
        #new width
        width: Int!
    ): Boolean
    "The transformed node"
    node: JCRNode
    "Resize an image under the current node"
    resizeImage(
        #new height
        height: Int!,
        #new width
        width: Int!
    ): Boolean
    "Rotate an image under the current node"
    rotateImage(
        #angle in degrees
        angle: Float!
    ): Boolean
}

type GqlLockDetail {
    language: String
    owner: String
    type: String
}

type GqlNews {
    date: String
    description(language: String!): String
    file: JCRNode
    title(language: String!): String
    uuid: String
}

"A connection to a list of items."
type GqlNewsConnection {
    "a list of edges"
    edges: [GqlNewsEdge]
    "a list of nodes"
    nodes: [GqlNews]
    "details about this specific page"
    pageInfo: PageInfo!
}

"An edge in a connection"
type GqlNewsEdge {
    "cursor marks a unique position or index into the connection"
    cursor: String!
    "index in the connection"
    index: Int
    "The item at the end of the edge"
    node: GqlNews
}

type GqlOperationsSupport {
    "Can node be locked"
    lock: Boolean
    "Can node be marked for deletion"
    markForDeletion: Boolean
    "does the node supports publication"
    publication: Boolean!
}

type GqlPublicationInfo {
    "Whether current user is allowed to publish the node omitting any workflows"
    allowedToPublishWithoutWorkflow: Boolean
    "Aggregated locked status of the node"
    locked: Boolean
    "Aggregated publication status of the node"
    publicationStatus: PublicationStatus!
    "Aggregated work-in-progress status of the node"
    workInProgress: Boolean
}

"Asset type for image"
type ImageAsset {
    cloudinary: CloudinaryAsset
    height: Long
    metadata: Metadata
    path: String
    size: Long
    "Mime type of image"
    type: String
    url: String
    uuid: String
    width: Long
}

type Images {
    height: Int
    path: String
    uuid: String
}

"JCR Mutations"
type JCRMutation {
    "Creates a new JCR node under the specified parent"
    addNode(
        children: [InputJCRNode],
        #The collection of mixin type names
        mixins: [String],
        #The name of the node to create
        name: String!,
        #The path or id of the parent node
        parentPathOrId: String!,
        #The primary node type of the node to create
        primaryNodeType: String!,
        properties: [InputJCRProperty]
    ): JCRNodeMutation
    "Batch creates a number of new JCR nodes under the specified parent"
    addNodesBatch(
        #The collection of nodes to create
        nodes: [InputJCRNodeWithParent]!
    ): [JCRNodeMutation]
    "Copy a single node to a different parent node"
    copyNode(
        #The name of the node at the new location or null if its current name should be preserved
        destName: String,
        #Path or UUID of the destination parent node to copy the node to
        destParentPathOrId: String!,
        #Path or UUID of the node to be copied
        pathOrId: String!
    ): JCRNodeMutation
    "Copy multiple nodes to different parent node(s)"
    copyNodes(nodes: [InputCarriedJCRNode!]!): [JCRNodeMutation]
    "Delete an existing node and all its children"
    deleteNode(
        #The path or id of the node to delete
        pathOrId: String!
    ): Boolean
    "Import a file under the specified parent"
    importContent(
        #Name of the request part that contains desired import file body
        file: String!,
        #The path or id of the parent node
        parentPathOrId: String!
    ): Boolean
    "Marks the existing node and all its children for deletion"
    markNodeForDeletion(
        #Optional deletion comment
        comment: String,
        #The path or id of the node to mark for deletion
        pathOrId: String!
    ): Boolean
    "Get a collection of nodes that were modified by current GraphQL request"
    modifiedNodes: [JCRNode]
    "Move a single node to a different parent node"
    moveNode(
        #The name of the node at the new location or null if its current name should be preserved
        destName: String,
        #Path or UUID of the destination parent node to move the node to
        destParentPathOrId: String!,
        #Path or UUID of the node to be moved
        pathOrId: String!
    ): JCRNodeMutation
    "Move multiple nodes to different parent node(s)"
    moveNodes(nodes: [InputCarriedJCRNode!]!): [JCRNodeMutation]
    "Mutates an existing node, based on path or id"
    mutateNode(
        #The path or id of the node to mutate
        pathOrId: String!
    ): JCRNodeMutation
    "Mutates a set of existing nodes, based on path or id"
    mutateNodes(
        #The paths or id ofs the nodes to mutate
        pathsOrIds: [String]!
    ): [JCRNodeMutation]
    "Mutates a set of existing nodes, based on query execution"
    mutateNodesByQuery(
        #The maximum size of the result set
        limit: Long,
        #The start offset of the result set
        offset: Long,
        #The query string
        query: String!,
        #The query language
        queryLanguage: QueryLanguage = SQL2
    ): [JCRNodeMutation]
    "Vanity URL Mutation"
    mutateVanityUrls(
        #Paths or UUIDs of vanity URL nodes to mutate
        pathsOrIds: [String]!
    ): [VanityUrlMappingMutation]
    "Paste a single node to a different parent node"
    pasteNode(
        #The name of the node at the new location or null if its current name should be preserved
        destName: String,
        #Path or UUID of the destination parent node to paste the node to
        destParentPathOrId: String!,
        #Paste mode, either COPY or MOVE
        mode: PasteMode!,
        #The way to deal with duplicate node names when they are not allowed, either FAIL or RENAME
        namingConflictResolution: NodeNamingConflictResolutionStrategy = FAIL,
        #Path or UUID of the node to be pasted
        pathOrId: String!
    ): JCRNodeMutation
    "Paste multiple nodes to different parent node(s)"
    pasteNodes(
        #Paste mode, either COPY or MOVE
        mode: PasteMode!,
        #The way to deal with duplicate node names when they are not allowed, either FAIL or RENAME
        namingConflictResolution: NodeNamingConflictResolutionStrategy = FAIL,
        #Info about nodes to paste and their new parent node(s)
        nodes: [InputCarriedJCRNode!]!
    ): [JCRNodeMutation]
    "Unmarks the specified node and all its children for deletion"
    unmarkNodeForDeletion(
        #The path or id of the node to unmark for deletion
        pathOrId: String!
    ): Boolean
}

"Aggregations on JCR Nodes"
type JCRNodeAggregation {
    "Average aggregation"
    avg: StatAggregation
    "Count aggregation"
    count: CountAggregation
    "Max aggregation"
    max: StatAggregation
    "Min aggregation"
    min: StatAggregation
    "Sum aggregation"
    sum: StatAggregation
}

"A connection to a list of items."
type JCRNodeConnection {
    aggregation: JCRNodeAggregation
    "a list of edges"
    edges: [JCRNodeEdge]
    "a list of nodes"
    nodes: [JCRNode]
    "details about this specific page"
    pageInfo: PageInfo!
}

"GraphQL representation of a JCR node definition"
type JCRNodeDefinition implements JCRItemDefinition {
    "Reports whether this child node can have same-name siblings. In other words, whether the parent node can have more than one child node of this name."
    allowsSameNameSiblings: Boolean!
    autoCreated: Boolean!
    declaringNodeType: JCRNodeType!
    "Gets the default primary node type that will be assigned to the child node if it is created without an explicitly specified primary node type."
    defaultPrimaryType: JCRNodeType
    hidden: Boolean!
    mandatory: Boolean!
    name: String!
    protected: Boolean!
    "Gets the minimum set of primary node types that the child node must have."
    requiredPrimaryType: [JCRNodeType]
}

"An edge in a connection"
type JCRNodeEdge {
    "cursor marks a unique position or index into the connection"
    cursor: String!
    "index in the connection"
    index: Int
    "The item at the end of the edge"
    node: JCRNode
}

"Mutations on a JCR node"
type JCRNodeMutation {
    "Creates a new JCR node under the current node"
    addChild(
        children: [InputJCRNode],
        #The collection of mixin type names
        mixins: [String],
        #The name of the node to create
        name: String!,
        #The primary node type of the node to create
        primaryNodeType: String!,
        properties: [InputJCRProperty]
    ): JCRNodeMutation
    "Batch creates a number of new JCR nodes under the current node"
    addChildrenBatch(
        #The collection of nodes to create
        nodes: [InputJCRNode]!
    ): [JCRNodeMutation]
    "Adds mixin types on the current node"
    addMixins(
        #The collection of mixin type names
        mixins: [String]!
    ): [String]
    "Add vanity URL"
    addVanityUrl(
        #The list of vanity url to create
        vanityUrlInputList: [InputVanityUrl]!
    ): [VanityUrlMappingMutation]
    "Unlock all nodes under the specified node"
    clearAllLocks: Boolean
    "Delete the current node (and its subgraph)"
    delete: Boolean
    "Import a file under the current node"
    importContent(
        #Name of the request part that contains desired import file body
        file: String!
    ): Boolean
    "Lock the node"
    lock(
        #Type of lock, defaults to user
        type: String = "user"
    ): Boolean
    "Mark the current node (and its subgraph) for deletion"
    markForDeletion(
        #Optional deletion comment
        comment: String
    ): Boolean
    "Moves the current node to a specified destination path (if destPath is specified) or moves it under the specified node (if parentPathOrId is specified). Either of two parameters is expected."
    move(
        #The target node path of the current node after the move operation
        destPath: String,
        #The parent node path or id under which the current node will be moved to
        parentPathOrId: String
    ): String
    "Mutates a set of existing direct sub nodes, based on filters passed as parameter"
    mutateChildren(
        #Filter of child nodes by their names; null to avoid such filtering
        names: [String],
        #Filter of child nodes by their property values; null to avoid such filtering
        propertiesFilter: InputNodePropertiesInput,
        #Filter of child nodes by their types; null to avoid such filtering
        typesFilter: InputNodeTypesInput
    ): [JCRNodeMutation]
    "Mutates an existing sub node, based on its relative path to the current node"
    mutateDescendant(
        #Name or relative path of the sub node to mutate
        relPath: String!
    ): JCRNodeMutation
    "Mutates a set of existing descendant nodes, based on filters passed as parameter"
    mutateDescendants(
        #Filter of descendant nodes by their property values; null to avoid such filtering
        propertiesFilter: InputNodePropertiesInput,
        #Filter out and stop recursion on nodes by their property values; null to avoid such filtering
        recursionPropertiesFilter: InputNodePropertiesInput,
        #Filter out and stop recursion on nodes by their types; null to avoid such filtering
        recursionTypesFilter: InputNodeTypesInput,
        #Filter of descendant nodes by their types; null to avoid such filtering
        typesFilter: InputNodeTypesInput
    ): [JCRNodeMutation]
    "Mutates or creates a set of properties on the current node"
    mutateProperties(
        #The names of the JCR properties; null to obtain all properties
        names: [String]
    ): [JCRPropertyMutation]
    "Mutates or creates a property on the current node"
    mutateProperty(
        #The name of the property to update
        name: String!
    ): JCRPropertyMutation
    "Update a vanity URL"
    mutateVanityUrl(
        #The url to edit
        url: String!
    ): VanityUrlMappingMutation
    "Update vanity URLs"
    mutateVanityUrls(
        #Filter by languages
        languages: [String]
    ): [VanityUrlMappingMutation]
    "Get the graphQL representation of the node currently being mutated"
    node: JCRNode
    "Publish the node in certain languages"
    publish(
        #Languages to publish the node in
        languages: [String],
        #Publish all sub and related nodes. Default is true.
        publishSubNodes: Boolean = true
    ): Boolean
    "Removes mixin types on the current node"
    removeMixins(
        #The collection of mixin type names
        mixins: [String]!
    ): [String]
    "Rename the current node"
    rename(
        #The new name of the node
        name: String!
    ): String
    "Reorder child nodes according to the list of names passed"
    reorderChildren(
        #List of child node names in the desired order
        names: [String]!,
        #The target position of reordered child nodes. The default value is inplace.
        position: ReorderedChildrenPosition = INPLACE
    ): Boolean
    "Mutates or creates a set of properties on the current node"
    setPropertiesBatch(
        #The collection of JCR properties to set
        properties: [InputJCRProperty]
    ): [JCRPropertyMutation]
    startWorkflow(definition: String, language: String): Boolean
    "Return image transformation mutation"
    transformImage(
        #name of target file, if different
        name: String,
        #target path, if different
        targetPath: String
    ): GqlJcrImageTransformMutation
    "Unlock the node"
    unlock(
        #Type of lock, defaults to user
        type: String = "user"
    ): Boolean
    "Unmark this node and all the sub-nodes for deletion"
    unmarkForDeletion: Boolean
    "Unpublish the node in certain languages"
    unpublish(
        #Languages to publish the node in
        languages: [String]
    ): Boolean
    "Get the identifier of the node currently being mutated"
    uuid: String
}

"GraphQL representation of a JCR node type"
type JCRNodeType {
    "Returns true if this is an abstract node type; returns false otherwise."
    abstract: Boolean
    displayName(language: String!): String
    "Returns true if nodes of this type must support orderable child nodes; returns false otherwise."
    hasOrderableChildNodes: Boolean
    icon: String
    "Returns true if this is a mixin type; returns false otherwise."
    mixin: Boolean
    name: String
    "Returns an array containing the child node definitions of this node type."
    nodes(
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput
    ): [JCRNodeDefinition]
    "Returns the name of the primary item (one of the child items of the nodes of this node type). If this node has no primary item, then this method null."
    primaryItem: JCRItemDefinition
    "Returns an array containing the property definitions of this node type."
    properties(
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput
    ): [JCRPropertyDefinition]
    "Returns true if the node type is queryable."
    queryable: Boolean
    "Returns all subtypes of this node type in the node type inheritance hierarchy."
    subTypes(
        #fetching only nodes after this node (exclusive)
        after: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        #fetching only the first certain number of nodes
        first: Int,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #fetching only nodes after this node (inclusive)
        offset: Int
    ): JCRNodeTypeConnection
    "Returns all supertypes of this node type in the node type inheritance hierarchy."
    supertypes(
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput
    ): [JCRNodeType]
    "System ID of the node type, corresponding to the name of the module declaring it."
    systemId: String
}

"A connection to a list of items."
type JCRNodeTypeConnection {
    "a list of edges"
    edges: [JCRNodeTypeEdge]
    "a list of nodes"
    nodes: [JCRNodeType]
    "details about this specific page"
    pageInfo: PageInfo!
}

"An edge in a connection"
type JCRNodeTypeEdge {
    "cursor marks a unique position or index into the connection"
    cursor: String!
    "index in the connection"
    index: Int
    "The item at the end of the edge"
    node: JCRNodeType
}

"GraphQL representation of a JCR property."
type JCRProperty {
    "Returns the property definition that applies to this property."
    definition: JCRPropertyDefinition
    "The value of the JCR property as a Float in case the property is single-valued, null otherwise"
    floatValue: Float
    "The values of the JCR property as Floats in case the property is multiple-valued, null otherwise"
    floatValues: [Float]
    "Whether the property is internationalized"
    internationalized: Boolean!
    "The language the property value was obtained in for internationalized properties; null for non-internationalized ones"
    language: String
    "The value of the JCR property as a Long in case the property is single-valued, null otherwise"
    longValue: Long
    "The values of the JCR property as Longs in case the property is multiple-valued, null otherwise"
    longValues: [Long]
    "The name of the JCR property"
    name: String!
    "The GraphQL representation of the JCR node the property belongs to."
    node: JCRNode!
    "The path of the JCR property"
    path: String!
    "GraphQL representation of the node this property references in case the property is single-valued, null otherwise"
    refNode: JCRNode
    "GraphQL representations of the nodes this property references in case the property is multiple-valued, null otherwise"
    refNodes: [JCRNode]
    "The type of the JCR property"
    type: JCRPropertyType!
    "The value of the JCR property as a String in case the property is single-valued, null otherwise"
    value: String
    "The values of the JCR property as Strings in case the property is multiple-valued, null otherwise"
    values: [String]
}

"A connection to a list of items."
type JCRPropertyConnection {
    "a list of edges"
    edges: [JCRPropertyEdge]
    "a list of nodes"
    nodes: [JCRProperty]
    "details about this specific page"
    pageInfo: PageInfo!
}

"GraphQL representation of a JCR property definition"
type JCRPropertyDefinition implements JCRItemDefinition {
    autoCreated: Boolean!
    constraints: [String]!
    declaringNodeType: JCRNodeType!
    "Gets the displayable name of the property for the given language code. Return the system name in case the label doesn't exists"
    displayName(language: String!): String!
    hidden: Boolean!
    "Reports whether this property has language dependant values."
    internationalized: Boolean!
    mandatory: Boolean!
    "Reports whether this property can have multiple values."
    multiple: Boolean!
    name: String!
    protected: Boolean!
    "Gets the required type of the property."
    requiredType: JCRPropertyType!
}

"An edge in a connection"
type JCRPropertyEdge {
    "cursor marks a unique position or index into the connection"
    cursor: String!
    "index in the connection"
    index: Int
    "The item at the end of the edge"
    node: JCRProperty
}

"Mutations on a JCR property"
type JCRPropertyMutation {
    "Add a new value to this property"
    addValue(language: String, type: JCRPropertyType, value: String): Boolean
    "Add new values to this property"
    addValues(language: String, type: JCRPropertyType, values: [String]): Boolean
    "Delete this property"
    delete(language: String): Boolean
    "Get the path of the property currently being mutated"
    path: String
    "Get the graphQL representation of the property currently being mutated"
    property: JCRProperty
    "Remove a new value from this property"
    removeValue(language: String, type: JCRPropertyType, value: String): Boolean
    "Remove values from this property"
    removeValues(language: String, type: JCRPropertyType, values: [String]): Boolean
    "Set property value"
    setValue(language: String, type: JCRPropertyType, value: String): Boolean
    "Set property values"
    setValues(language: String, type: JCRPropertyType, values: [String]): Boolean
}

"JCR Queries"
type JCRQuery {
    "Retrieves the number of active workflow tasks for the current user"
    activeWorkflowTaskCountForUser: Int
    "Get GraphQL representation of a node by its UUID"
    nodeById(
        #The UUID of the node
        uuid: String!
    ): JCRNode!
    "Get GraphQL representation of a node by its path"
    nodeByPath(
        #The path of the node
        path: String!
    ): JCRNode!
    "Get a node type by its name"
    nodeTypeByName(name: String!): JCRNodeType
    "Get a list of nodetypes based on specified parameter"
    nodeTypes(
        #fetching only nodes after this node (exclusive)
        after: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput,
        filter: InputNodeTypesListInput,
        #fetching only the first certain number of nodes
        first: Int,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #fetching only nodes after this node (inclusive)
        offset: Int
    ): JCRNodeTypeConnection
    "Get multiple node types by their names"
    nodeTypesByNames(names: [String]!): [JCRNodeType]
    "handles query nodes with QOM factory"
    nodesByCriteria(
        #fetching only nodes after this node (exclusive)
        after: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        #The criteria to fetch nodes by
        criteria: InputGqlJcrNodeCriteriaInput!,
        #Filter by GraphQL field values
        fieldFilter: InputFieldFiltersInput,
        #Group fields by criteria
        fieldGrouping: InputFieldGroupingInput,
        #sort by GraphQL field values
        fieldSorter: InputFieldSorterInput,
        #fetching only the first certain number of nodes
        first: Int,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #fetching only nodes after this node (inclusive)
        offset: Int
    ): JCRNodeConnection
    "Get GraphQL representations of multiple nodes by their UUIDs"
    nodesById(
        #The UUIDs of the nodes
        uuids: [String!]!
    ): [JCRNode]!
    "Get GraphQL representations of multiple nodes by their paths"
    nodesByPath(
        #The paths of the nodes
        paths: [String!]!
    ): [JCRNode]!
    "Get GraphQL representations of nodes using a query language supported by JCR"
    nodesByQuery(
        #fetching only nodes after this node (exclusive)
        after: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        #Filter by graphQL fields values
        fieldFilter: InputFieldFiltersInput,
        #Group fields by criteria
        fieldGrouping: InputFieldGroupingInput,
        #sort by GraphQL field values
        fieldSorter: InputFieldSorterInput,
        #fetching only the first certain number of nodes
        first: Int,
        #Language to access node properties in
        language: String,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #fetching only nodes after this node (inclusive)
        offset: Int,
        #The query string
        query: String!,
        #The query language
        queryLanguage: QueryLanguage = SQL2
    ): JCRNodeConnection
    "Get the workspace of the query"
    workspace: Workspace!
}


type JCRSiteLanguage {
    activeInEdit: Boolean
    activeInLive: Boolean
    displayName(language: String): String
    language: String
    mandatory: Boolean
}

type JWTToken {
    claims: String
    id: String
    token: String
}

"GraphQL object representing form label"
type Label {
    choices: String
    defaultLabel: Boolean
    fieldId: String
    label: String
    language: String
}

type LockInfo {
    "Can the node be locked"
    canLock: Boolean
    "Can the node be unlocked"
    canUnlock: Boolean
    "Is node lockable"
    details(
        #language in which to retrieve details
        language: String
    ): [GqlLockDetail]
    "Is node lockable"
    lockable: Boolean
}

"Metadata properties for all content"
type Metadata {
    "Date of creation for the associated content"
    created: Date
    createdBy: String
    lastModified: Date
    lastModifiedBy: String
    lastPublished: Date
    lastPublishedBy: String
    path: String
    uuid: String
}

"Root mutation type"
type Mutation {
    "Form Factory Elasticsearch Storage Queries"
    ffesstorage: FFESMutation
    "JCR Mutation"
    jcr(
        #The name of the workspace to fetch the node from; either 'edit', 'live', or null to use 'edit' by default
        workspace: Workspace
    ): JCRMutation
    "Generate a new JWT token"
    jwtToken(ips: [String], referer: [String], scopes: [String]): JWTToken
    mutateWorkflows(definition: String): [WorkflowMutation]
}

"This is news"
type NewsSDL {
    "This is something"
    checked: Boolean
    "This is date"
    date: Date
    "This is description"
    description(
        #The language
        language: String
    ): String
    path: String
    "This is title"
    title(
        #The language
        language: String
    ): String
    uuid: String
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating forwards, the cursor to continue."
    nodesCount: Int
    "When paginating backwards, the cursor to continue."
    startCursor: String
    "When paginating forwards, the cursor to continue."
    totalCount: Int
}

"Root query type"
type Query {
    allDestination(
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false,
        #Sort filter object
        sortBy: InputFieldSorterInput
    ): [Destination]
    "default finder for categoryById"
    categoryById(
        id: String,
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false
    ): Category
    "default finder for categoryByPath"
    categoryByPath(
        #Content language, defaults to English
        language: String = "en",
        path: String,
        #Return content from live or default workspace
        preview: Boolean = false
    ): Category
    destinationByHighlight(
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false,
        #Sort filter object
        sortBy: InputFieldSorterInput,
        #select content if boolean value true or false
        value: Boolean = true
    ): [Destination]
    "default finder for destinationById"
    destinationById(
        id: String,
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false
    ): Destination
    "default finder for destinationByPath"
    destinationByPath(
        #Content language, defaults to English
        language: String = "en",
        path: String,
        #Return content from live or default workspace
        preview: Boolean = false
    ): Destination
    destinationBySystemName(
        #Property contains passed parameter
        contains: String,
        #Property is equal to passed parameter
        equals: String,
        #Inverts 'contains' or 'equals' argument to get either 'not contains' or 'not equals'. Default value is 'false'
        invert: Boolean = false,
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false,
        #Sort filter object
        sortBy: InputFieldSorterInput
    ): [Destination]
    "default finder for destinationInfoById"
    destinationInfoById(
        id: String,
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false
    ): DestinationInfo
    "default finder for destinationInfoByPath"
    destinationInfoByPath(
        #Content language, defaults to English
        language: String = "en",
        path: String,
        #Return content from live or default workspace
        preview: Boolean = false
    ): DestinationInfo
    "Form Factory Elasticsearch Storage Queries"
    ffesstorage: FFESQuery
    "default finder for geoTagById"
    geoTagById(
        id: String,
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false
    ): GeoTag
    "default finder for geoTagByPath"
    geoTagByPath(
        #Content language, defaults to English
        language: String = "en",
        path: String,
        #Return content from live or default workspace
        preview: Boolean = false
    ): GeoTag
    "JCR Queries"
    jcr(
        #The name of the workspace to fetch the node from; either EDIT, LIVE, or null to use EDIT by default
        workspace: Workspace
    ): JCRQuery
    myImagesByHeight(
        #Property equal to passed parameter
        eq: Int,
        #Property greater than passed parameter
        gt: Int,
        #Property greater than or equal to passed parameter
        gte: Int,
        #Content language, defaults to English
        language: String = "en",
        #Property less than passed parameter
        lt: Int,
        #Property less than or equal to passed parameter
        lte: Int,
        #Property not equal to passed parameter
        noteq: Int,
        #Return content from live or default workspace
        preview: Boolean = false,
        #Sort filter object
        sortBy: InputFieldSorterInput
    ): [Images]
    myNewsByDate(
        #Select content after date
        after: String,
        #Select content before date
        before: String,
        #Content language, defaults to English
        language: String = "en",
        #Select content within last days
        lastDays: Int,
        #Return content from live or default workspace
        preview: Boolean = false,
        #Sort filter object
        sortBy: InputFieldSorterInput
    ): [NewsSDL]
    newsByChecked(
        #Content language, defaults to English
        language: String = "en",
        #Return content from live or default workspace
        preview: Boolean = false,
        #Sort filter object
        sortBy: InputFieldSorterInput,
        #select content if boolean value true or false
        value: Boolean = true
    ): [NewsSDL]
    newsByDate(
        #fetching only nodes after this node (exclusive)
        after: String,
        afterDate: String,
        #fetching only nodes before this node (exclusive)
        before: String,
        beforeDate: String,
        #fetching only the first certain number of nodes
        first: Int,
        #fetching only the last certain number of nodes
        last: Int,
        #fetching only the first certain number of nodes
        limit: Int,
        #fetching only nodes after this node (inclusive)
        offset: Int
    ): GqlNewsConnection
    newsById(id: String): GqlNews
    newsByPath(path: String): GqlNews
    testExtension(arg: String): String
}

type RenderedNode {
    constraints: String
    output: String
    staticAssets(type: String!): [StaticAsset]
}

type StatAggregation {
    "The date representation of a JCR node property"
    datePropertyValue(
        #The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
        language: String,
        #The name of the JCR property
        name: String!
    ): String
    "The float representation of a JCR node property"
    floatPropertyValue(
        #The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
        language: String,
        #The name of the JCR property
        name: String!
    ): Float
    "The long representation of a JCR node property"
    longPropertyValue(
        #The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
        language: String,
        #The name of the JCR property
        name: String!
    ): Long
}

type StaticAsset {
    key: String
    option(name: String!): String
}

"Root subscription type"
type Subscription {
    "Subscription on background jobs"
    backgroundJobSubscription(
        #Subscribe only to job with matching group names
        filterByGroups: [String],
        #Subscribe only to job with matching job states
        filterByJobStates: [GqlBackgroundJobState],
        #Subscribe only to job with matching job statuses
        filterByJobStatuses: [GqlBackgroundJobStatus],
        #Subscribe only to job with matching names
        filterByNames: [String],
        #The target scheduler for listening jobs
        targetScheduler: TargetScheduler = BOTH
    ): GqlBackgroundJob
}

type VanityUrlMappingMutation {
    "Deletes the current vanity url"
    delete: Boolean
    "Move the vanity URL to another node"
    move(
        #The path of the target node
        target: String!
    ): Boolean
    "Get mutation on underlying node"
    nodeMutation: JCRNodeMutation
    "Update vanity URL"
    update(
        #Desired value of the active flag or null to keep existing value
        active: Boolean,
        #Desired value of the default flag or null to keep existing value
        defaultMapping: Boolean,
        #Desired vanity URL language or null to keep existing value
        language: String,
        #Desired URL value or null to keep existing value
        url: String
    ): Boolean
    "Get the identifier of the node currently being mutated"
    uuid: String
}

type Workflow {
    startUser: String
}

type WorkflowMutation {
    abortWorkflow: Boolean
    workflow: Workflow
}

enum AverageBy {
    #Average by day
    DAY
    #Average by month
    MONTH
    #Average by week
    WEEK
    #Average by year
    YEAR
}

enum FieldEvaluation {
    #The property value is among given Strings
    AMONG
    #The property value contains given String
    CONTAINS
    #The property value contains given String ignoring the case
    CONTAINS_IGNORE_CASE
    #The field value is different from given one
    DIFFERENT
    #The field value is empty - either null value, or no items for a list
    EMPTY
    #The field value is equal to given one
    EQUAL
    #The field value is not empty - if a list, must contain at least one item
    NOT_EMPTY
}

enum GqlBackgroundJobState {
    #FINISHED
    FINISHED
    #STARTED
    STARTED
    #VETOED
    VETOED
}

enum GqlBackgroundJobStatus {
    #ADDED
    ADDED
    #CANCELED
    CANCELED
    #EXECUTING
    EXECUTING
    #FAILED
    FAILED
    #SCHEDULED
    SCHEDULED
    #SUCCESSFUL
    SUCCESSFUL
}

enum GroupingType {
    #Put grouped items at the end in the order groups appear in the 'groups' list
    END
    #Put grouped items at the start in the order groups appear in the 'groups' list
    START
}

enum JCRPropertyType {
    #BINARY
    BINARY
    #BOOLEAN
    BOOLEAN
    #DATE
    DATE
    #DECIMAL
    DECIMAL
    #DOUBLE
    DOUBLE
    #LONG
    LONG
    #NAME
    NAME
    #PATH
    PATH
    #REFERENCE
    REFERENCE
    #STRING
    STRING
    #UNDEFINED
    UNDEFINED
    #URI
    URI
    #WEAKREFERENCE
    WEAKREFERENCE
}

enum MulticriteriaEvaluation {
    #The result criteria evaluates positive if all sub-criteria evaluate positive
    ALL
    #The result criteria evaluates positive if any sub-criteria evaluates positive
    ANY
    #The result criteria evaluates positive if no sub-criteria evaluates positive
    NONE
}

enum NodeNamingConflictResolutionStrategy {
    #FAIL
    FAIL
    #RENAME
    RENAME
}

enum OrderType {
    #Ascendant order
    ASC
    #Descendant order
    DESC
}

enum PasteMode {
    #COPY
    COPY
    #MOVE
    MOVE
}

enum PathType {
    #The specified path is an ancestor, so all its descendants will be considered in the query
    ANCESTOR
    #The specified path is a node itself, so only this node will be considered in the query
    OWN
    #The specified path is a parent, so all its direct children will be considered in the query
    PARENT
}

enum PropertyEvaluation {
    #The property is absent
    ABSENT
    #The property value is different from given one
    DIFFERENT
    #The property value is equal to given one
    EQUAL
    #The property is present
    PRESENT
}

enum PublicationStatus {
    #CONFLICT
    CONFLICT
    #DELETED
    DELETED
    #LIVE_MODIFIED
    LIVE_MODIFIED
    #LIVE_ONLY
    LIVE_ONLY
    #MANDATORY_LANGUAGE_UNPUBLISHABLE
    MANDATORY_LANGUAGE_UNPUBLISHABLE
    #MANDATORY_LANGUAGE_VALID
    MANDATORY_LANGUAGE_VALID
    #MARKED_FOR_DELETION
    MARKED_FOR_DELETION
    #MODIFIED
    MODIFIED
    #NOT_PUBLISHED
    NOT_PUBLISHED
    #PUBLISHED
    PUBLISHED
    #UNPUBLISHED
    UNPUBLISHED
}

enum QueryFunction {
    #Query function for lower case comparison
    LOWER_CASE
    #Query function for node local name comparison
    NODE_LOCAL_NAME
    #Query function for node name comparison
    NODE_NAME
    #Query function for upper case comparison
    UPPER_CASE
}

"JCR query languages available to use for nodes querying"
enum QueryLanguage {
    #SQL2 query language
    SQL2
    #XPath query language
    XPATH
}

"The target position of reordered child nodes"
enum ReorderedChildrenPosition {
    #Specified children are sorted in a requested order and placed at the top, before all remaining children
    FIRST
    #Specified children are sorted in a requested order, but remaining are kept at their places
    INPLACE
    #Specified children are sorted in a requested order and placed at the end of the list after the remaining children
    LAST
}

enum SortType {
    #Ascendant order
    ASC
    #Descendant order
    DESC
}

"The target scheduler(s)"
enum TargetScheduler {
    #Both persisted and RAM schedulers will be used
    BOTH
    #RAM scheduler will be used
    RAM_SCHEDULER
    #Persisted scheduler will be used
    SCHEDULER
}

"JCR workspace to use for the operations"
enum Workspace {
    #Edit workspace
    EDIT
    #Live workspace
    LIVE
}

"Info about a node to be reproduced at (moved or copied to) another parent node"
input InputCarriedJCRNode {
    "The name of the node at the new location or null if its current name should be preserved"
    destName: String
    "Path or UUID of the destination parent node to copy/move the node to"
    destParentPathOrId: String!
    "Path or UUID of the node to be copied/moved"
    pathOrId: String!
}

"Input object representing either a sub-filter (so that nested conditional logic can be composed), or a condition to filter by a single field"
input InputFieldFilterInput {
    "The way to evaluate the property; null indicates default (EQUAL)"
    evaluation: FieldEvaluation
    "Either a non-null sub-filter, or null in case the input object represents a simple field filter configured via its other properties"
    fieldFilter: InputFieldFiltersInput
    "The name of the field or its alias to filter by"
    fieldName: String
    "The value to evaluate the field against (for single-valued operations)"
    value: String
    "The values to evaluate the field against (for multi-valued operations)"
    values: [String]
}

"Filter any GraphQL node based on a sub-fields values"
input InputFieldFiltersInput {
    "Individual property filters"
    filters: [InputFieldFilterInput]!
    "The way to combine multiple individual property filters; null indicates default (ALL)"
    multi: MulticriteriaEvaluation
}

"Group entries according to criteria"
input InputFieldGroupingInput {
    "fieldName to group on"
    fieldName: String!
    "grouping type"
    groupingType: GroupingType!
    "specified groups"
    groups: [String]!
}

"object with fieldName and sort direction (ASC/DESC)"
input InputFieldSorterInput {
    "fieldName to sort"
    fieldName: String
    "ignore case when sorting"
    ignoreCase: Boolean
    "direction of the sort"
    sortType: SortType
}

"An optional part of the JCR node criteria to filter nodes, specifically by their arbitrary properties"
input InputGqlJcrNodeConstraintInput {
    "A list of child constraint input for all composition"
    all: [InputGqlJcrNodeConstraintInput]
    "A list of child constraint input for any composition"
    any: [InputGqlJcrNodeConstraintInput]
    "A search expression to match the node property value(s) against, either specific property only or all node properties, dependent on the 'property' parameter value passed"
    contains: String
    "A value to compare the node property value to, using the 'equals to' operator"
    equals: String
    "A value to compare the node property value to, using the 'exists' operator"
    exists: Boolean
    "The query function name for the node for comparison"
    function: QueryFunction
    "A value to compare the node property value to, using the 'greater than' operator"
    gt: String
    "A value to compare the node property value to, using the 'greater than or equals to' operator"
    gte: String
    "A value to pick the last days for node property date value, using the 'lastDays' operator"
    lastDays: Int
    "A value to compare the node property value to, using the 'like' operator"
    like: String
    "A value to compare the node property value to, using the 'less than' operator"
    lt: String
    "A value to compare the node property value to, using the 'less than or equals to' operator"
    lte: String
    "A list of child constraint input for none composition"
    none: [InputGqlJcrNodeConstraintInput]
    "A value to compare the node property value to, using the 'not equals to' operator"
    notEquals: String
    "The name of the node property to compare/match; may be null when optional or not applicable, dependent on other parameter values"
    property: String
}

input InputGqlJcrNodeCriteriaInput {
    "Language to access node properties in"
    language: String
    "Additional constraint to filter nodes by their arbitrary properties"
    nodeConstraint: InputGqlJcrNodeConstraintInput
    "The type of nodes to query"
    nodeType: String!
    "Ordering strategies"
    ordering: InputGqlOrdering
    "The exact meaning of the paths field"
    pathType: PathType
    "Paths that restrict areas to fetch nodes from; the exact meaning is defined by the pathType field; null or empty collection means no path restrictions"
    paths: [String]
}

input InputGqlOrdering {
    "ASC or DESC order"
    orderType: OrderType
    "The property to order by"
    property: String
}

"GraphQL representation of a JCR node to be created"
input InputJCRNode {
    "The collection of sub nodes to create"
    children: [InputJCRNode]
    "The collection of mixins to add to the node"
    mixins: [String]
    "The name of the node to create"
    name: String!
    "The primary node type of the node to create"
    primaryNodeType: String!
    "The collection of properties to set to the node"
    properties: [InputJCRProperty]
}

"GraphQL representation of a JCR node to be created"
input InputJCRNodeWithParent {
    "The collection of sub nodes to create"
    children: [InputJCRNode]
    "The collection of mixins to add to the node"
    mixins: [String]
    "The name of the node to create"
    name: String!
    "The parent path or id where the node will be created"
    parentPathOrId: String!
    "The primary node type of the node to create"
    primaryNodeType: String!
    "The collection of properties to set to the node"
    properties: [InputJCRProperty]
}

"GraphQL representation of a JCR property to set"
input InputJCRProperty {
    "The language in which the property will be set (for internationalized properties"
    language: String
    "The name of the property to set"
    name: String!
    "The type of the property"
    type: JCRPropertyType
    "The value to set (for single valued properties)"
    value: String
    "The values to set (for multivalued properties)"
    values: [String]
}

input InputNodePropertiesInput {
    "Individual property filters"
    filters: [InputNodePropertyInput]!
    "The way to combine multiple individual property filters; null indicates default (ALL)"
    multi: MulticriteriaEvaluation
}

input InputNodePropertyInput {
    "The way to evaluate the property; null indicates default (EQUAL)"
    evaluation: PropertyEvaluation
    "Language to use when evaluating the property"
    language: String
    "The name of the property to filter by"
    property: String!
    "The value to evaluate the property against"
    value: String
}

input InputNodeTypesInput {
    "The way to combine multiple type criteria; null indicates default (ANY)"
    multi: MulticriteriaEvaluation
    "Node type names required for a node to pass the filter"
    types: [String]!
}

input InputNodeTypesListInput {
    "Consider sub-types when checking for included/excluded nodetypes (default true)"
    considerSubTypes: Boolean
    "Exclude the types, specified by this list (also considering sub-types, if considerSubTypes is true)"
    excludeTypes: [String]
    "Include abstract types (default true)"
    includeAbstract: Boolean
    "Include mixin types (default true)"
    includeMixins: Boolean
    "Include non mixin types (default true)"
    includeNonMixins: Boolean
    "Only include types specified by this list (also considering sub-types, if considerSubTypes is true)"
    includeTypes: [String]
    "Filter on nodetypes defined in these modules"
    modules: [String]
    "Consider only nodetypes for the specified site"
    siteKey: String
}

input InputVanityUrl {
    "true if the URL mapping is activated or false if it is not activated"
    active: Boolean
    "true whether this URL mapping is the default one for the language"
    defaultMapping: Boolean!
    "The language of the content object to which the vanity URL maps to"
    language: String!
    "The vanity URL"
    url: String!
}


"Long type"
scalar Long

"Date type"
scalar Date